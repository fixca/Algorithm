2022/03/16

#9935번 문제 (Java)
https://www.acmicpc.net/problem/9935

역대급으로 뻘짓을 굉장히 많이 했던 문제가 아닐까, 싶다   
처음에는 폭발 대상 문자를 스택에 집어넣고 폭발 중을 검사할때 덱에 집어넣는 별에별 쇼를 다했다.   
결과는 뻔하게 메모리 초과.   
   

두번째 접근은 폭발 대상을 덱에, 폭발 중을 검사할때 또 덱에 집어넣었다.   
비교는 deque.toString을 비교로 했다.   
당연히도 결과는 메모리 초과, 풀고 나서 깨달은 거지만 이 문제에서 스택은 1번 이상 쓰이게 되는 순간 게임 오버라고 생각한다.   
   
세번째 접근은 폭발 대상을 char 배열에 담기로 했다.   
그리고 비교할 또다른 char 배열을 만들었다.   
비교는 Arrays에 있는 equals를 사용했는데, 그래도 메모리 초과가 떴던걸 보면 이 방법도 아니었다.   
   
네번째 접근은 비교 대상만 스택에 저장하고 나머지엔 반복문에서 비교를 하기로 했다.   
뭐 char 배열 또다른 덱 다 필요 없이 수작업으로 비교하기로 하였다.   
그런 와중에 한가지 배운게 있는데, 스택은 get이라는 메소드를 사용해서 배열 처럼 쓸 수 있다.   
이걸 이용하면 반복문에서 비교가 가능하다.   
흔히 쓰는 원초적 방법으로 폭발 대상 문자의 길이 만큼 반복문을 돌리고 하나라도 문자가 안맞을 경우 폭발 대상이 아니므로 break, 플래그를 false로 바꾸고 반복문 탈출.   
내가 생각하는 비교의 원초적 대상이지만 가끔은 이게 빠르다고 생각한다.   
비교를 끝낸 최종 스택을 출력할 차례 였는데, 어마어마한 실수를 저질러 버렸다.   
```java
for(Character c : stack) {
    System.out.print(c);
}
```
를 해버린 것이다.   
진짜 Java를 사용해서 알고리즘을 풀땐 하지도 않는 멍청한 짓을 해버린 것이다.   
그렇게 삽질의 제출을 6번이나 한 후에서야 깨닫고 StringBuilder 안에 집어넣은 후에 출력을 했고 정답이 나왔다.   
역시 난 바보가 맞는거 같다.